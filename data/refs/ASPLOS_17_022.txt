[1] Chrome rewards. https://www.google.com/about/
appsecurity/chrome-rewards/. Accessed: Aug 2016.

[2] A. Andoni, D. Daniliuc, S. Khurshid, and D. Marinov. Evaluating the “small scope hypothesis”. In Principles of Programming Languages (POPL), 2002.

[3] T. Arons, E. Elster, L. Fix, S. Mador-Haim, M. Mishaeli,
J. Shalev, E. Singerman, A. Tiemeyer, M. Y. Vardi, and L. D.
Zuck. Formal verification of backward compatibility of microcode. In Computer Aided Verification (CAV), 2005.

[4] V. Bala, E. Duesterwald, and S$. Banerjia. Dynamo: A transparent dynamic optimization system. In Programming Language Design and Implementation (PLDI), 2000.

[5] G. Balakrishnan and T. W. Reps. WYSINWYX: What you see
is not what you execute. ACM Transactions on Programming
Languages and Systems, 32(6), 2010.

[6] D. Brumley, C. Hartwig, M. G. Kang, Z. L. J. Newsome,
P. Poosankam, D. Song, and H. Yin. Bitscope: Automatically
dissecting malicious binaries. Technical report, School of
Computer Science, Carnegie Mellon University, 2007.

[7] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz. BAP:
A binary analysis platform. In Computer Aided Verification
(CAV), 2011.

[8] M. Castro, M. Costa, J.-P. Martin, M. Peinado, P. Akritidis,
A. Donnelly, P. Barham, and R. Black. Fast byte-granularity
software fault isolation. In Symposium on Operating Systems
Principles (SOSP), 2009.

[9] A. Chernoff, M. Herdeg, R. Hookway, C. Reeve, N. Rubin,
T. Tye, S. B. Yadavalli, and J. Yates. Fx! 32: A profile-directed
binary translator. JEEE Micro, 18(2), 1998.

[10] V. Chipounov, V. Kuznetsov, and G. Candea. S2E: A platform
for in-vivo multi-path analysis of software systems. In Architectural Support for Programming Languages and Operating
Systems (ASPLOS), 2011.

[11] D. Currie, X. Feng, M. Fujita, A. J. Hu, M. Kwan, and S. Rajan. Embedded software verification using symbolic execution
and uninterpreted functions. International Journal of Parallel
Programming, 32(3), 2006.

[12] D. W. Currie, A. J. Hu, and S. P. Rajan. Automatic formal verification of DSP software. In Design Automation Conference
(DAC), 2000.

[13] L. De Moura and N. Bjgrner. Z3: An efficient SMT solver.
In Theory and Practice of Software, Tools and Algorithms for
the Construction and Analysis of Systems (TACAS), 2008.

[14] M. Elder, J. Lim, T. Sharma, T. Andersen, and T. Reps. Abstract domains of affine relations. ACM Transactions on Programming Languages and Systems, 36(4), 2014.

[15] D. Felsing, S. Grebing, V. Klebanov, P. Riimmer, and M. UIbrich. Automating regression verification. In Automated Software Engineering (ASE), 2014.

[16] X. Feng and A. J. Hu. Automatic formal verification for
scheduled VLIW code. In Languages, Compilers and Tools
for Embedded Systems: Software and Compilers for Embedded Systems (LCTES-SCOPES), 2002.

[17] X. Feng and A. J. Hu. Cutpoints for formal equivalence
verification of embedded software. In Embedded Software
(EMSOFT), 2005.

[18] C. Flanagan and K. R. M. Leino. Houdini: An annotation
assistant for ESC/Java. In Formal Methods Europe (FME),
2001.

[19] B. Godlin and O. Strichman. Regression verification. In
Design Automation Conference (DAC), 2009.

[20] B. Goldberg, L. Zuck, and C. Barrett. Into the loops: Practical
issues in translation validation for optimizing compilers. Electronic Notes in Theoretical Computer Science, 132(1), 2005.

[21] S. Gulwani, S. Jha, A. Tiwari, and R. Venkatesan. Synthesis
of loop-free programs. In Programming Language Design and
Implementation, (PLDI), 2011.

[22] C. Hawblitzel, S. Lahiri, K. Pawar, H. Hashmi, S$. Gokbulut,
L. Fernando, D. Detlefs, and S. Wadsworth. Will you still
compile me tomorrow? Static cross-version compiler validation. In Foundations of Software Engineering (FSE), 2013.

[23] S. Heule, E. Schkufza, R. Sharma, and A. Aiken. Stratified synthesis: Automatically learning the x86-64 instruction
set. In Programming Language Design and Implementation
(PLDI), 2016.

[24] D. Jackson and C. A. Damon. Elements of Style: Analyzing
a software design feature with a counterexample detector. In
Software Testing and Analysis (ISSTA), 1996.

[25] R. Joshi, G. Nelson, and Y. Zhou. Denali: A practical algorithm for generating optimal code. ACM Transactions on Programming Languages and Systems, 28(6), 2006.

[26] X. Leroy. A formally verified compiler back-end. Journal of
Automated Reasoning, 43(4), 2009.

[27] P. Mangpo, A. Thakur, R. Bodik, and D. Dhurjati. Scaling up
superoptimization. In Architectural Support for Programming
Languages and Operating Systems (ASPLOS), 2016.

[28] O. Mao, H. Chen, D. Zhou, X. Wang, N. Zeldovich, and M. F.
Kaashoek. Software fault isolation with API integrity and
multi-principal modules. In Symposium on Operating Systems
Principles (SOSP), 2011.

[29] H. Massalin. Superoptimizer - a look at the smallest program.
In Architectural Support for Programming Languages and
Operating Systems (ASPLOS), 1987.

[30] G. C. Necula. Translation validation for an optimizing compiler. ACM Sigplan Notices, 35(5), 2000.

[31] J. Oetsch, M. Prischink, J. Ptihrer, M. Schwengerer, and
H. Tompits. On the small-scope hypothesis for testing answerset programs. In Principles of Knowledge Representation and
Reasoning, 2012.

[32] N. Partush and E. Yahav. Abstract semantic differencing for
numerical programs. In Static Analysis Symposium (SAS),
2013.

[33] S. Person, M. B. Dwyer, S. G. Elbaum, and C. S. Pasareanu.
Differential symbolic execution. In Foundations of Software
Engineering (F SE), 2008.

[34] A. Pnueli, M. Siegel, and E. Singerman. Translation validation. In Jools and Algorithms for Construction and Analysis
of Systems (TACAS), 1998.

[35] D. A. Ramos and D. R. Engler. Practical, low-effort equivalence verification of real code. In Computer Aided Verification
(CAV), 2011.

[36] E. Schkufza, R. Sharma, and A. Aiken. Stochastic superoptimization. In Architectural Support for Programming Languages and Operating Systems (ASPLOS), 2013.

[37] E. Schulte, J. Dorn, S. Harding, S. Forrest, and W. Weimer.
Post-compiler software optimization for reducing energy. In
Architectural Support for Programming Languages and Operating Systems (ASPLOS), 2014.

[38] D. Sehr, R. Muth, C. L. Biffle, V. Khimenko, E. Pasko, B. Yee,
K. Schimpf, and B. Chen. Adapting software fault isolation
to contemporary CPU architectures. In USENIX Security
Symposium, 2010.

[39] R. Sharma, E. Schkufza, B. R. Churchill, and A. Aiken.
Data-driven equivalence checking. In Object-Oriented Programming, Systems, Languages, and Applications, (OOPSLA), 2013.

[40] R. Sharma, E. Schkufza, B. Churchill, and A. Aiken. Conditionally correct superoptimization. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA),
2015.

[41] K. C. Shashidhar, M. Bruynooghe, F. Catthoor, and
G. Janssens. Verification of source code transformations by
program equivalence checking. In Compiler Construction,
2005.

[42] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna. Firmalice - automatic detection of authentication bypass
vulnerabilities in binary firmware. In Network and Distributed
System Security Symposium (NDSS), 2015.

[43] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G.
Kang, Z. Liang, J. Newsome, P. Poosankam, and P. Saxena.
BitBlaze: A new approach to computer security via binary
analysis. In Information Systems Security (ICISS), 2008.

[44] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham.
Efficient software-based fault isolation. SIGOPS Operating
Systems Review, 27(5), 1994.

[45] W. Wang. Partitioned Memory Models for Program Analysis.
Ph.D., New York University, 2016.

[46] B. Yee, D. Sehr, G. Dardyk, B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar. Native client: A
sandbox for portable, untrusted x86 native code. In IEEE
Symposium on Security and Privacy (Oakland), 2009.