[1] Dotty Compiler. http: //dotty.epfl.ch/.

[2] Perennial, Inc. Perennial C Compiler Validation Suite. http:
//www.peren.com/pages/cvsa_set .htm.

[3] Plum Hall, Inc. The Plum Hall Validation Suite for C. http:
//wew.plumhall.com/stec.html.

[4] Scala Compiler. http: //www.scala- lang.org/.

[5] A. Balestrat. CCG. https: //github. com/Mrktn/ccg.

[6] A. S. Boujarwah and K. Saleh. Compiler test case generation
methods: a survey and assessment. Information & Software
Technology, 39(9):617-625, 1997.

[7] C. Boyapati, S. Khurshid, and D. Marinov. Korat: automated
testing based on Java predicates. In ISSTA, pages 123-133,
2002.

[8] F. Briggs and M. O’Neill. Functional genetic programming
and exhaustive program search with combinator expressions.
KES Journal, 12(1):47-68, 2008.

[9] Y. Chen, A. Groce, C. Zhang, W. Wong, X. Fern, E. Eide, and
J. Regehr. Taming compiler fuzzers. In PLDI, pages 197-208,
2013.

[10] K. Claessen and J. Hughes. QuickCheck: a lightweight tool for
random testing of Haskell programs. In ICFP, pages 268-279,
2000.

[11] K. Claessen, J. Duregard, and M. H. Palka. Generating
constrained random data with uniform distribution. J. Funct.
Program., 25, 2015.

[12] B. Daniel, D. Dig, K. Garcia, and D. Marinov. Automated
testing of refactoring engines. In FSE, pages 185-194, 2007.

[13] S. M. Daniel S. Wilkerson and S. Goldsmith. Berkeley Delta.
http://delta.stage.tigris.org/.

[14] N. G. De Bruijn. Lambda calculus notation with nameless
dummies, a tool for automatic formula manipulation, with
application to the Church-Rosser theorem. In Indagationes
Mathematicae, volume 75, pages 381-392, 1972.
[15] R. A. DeMillo, R. J. Lipton, and FE G. Sayward. Hints on
test data selection: Help for the practicing programmer. [EEE
Computer, 11(4):34-41, 1978.

[16] J. Duregard, P. Jansson, and M. Wang. Feat: functional
enumeration of algebraic types. In Haskell, pages 61-72, 2012.

[17] C. Ellison and G. Rosu. An executable formal semantics of C
with applications. In POPL, pages 533-544, 2012.

[18] B. Fetscher, K. Claessen, M. H. Palka, J. Hughes, and R. B.
Findler. Making random judgments: Automatically generating
well-typed terms from the definition of a type-system. In ESOP,
pages 383-405, 2015.

[19] J. PB. Galeotti, N. Rosner, C. G. L. Pombo, and M. F. Frias.
TACO: efficient SAT-based bounded verification using symmetry breaking and tight bounds. IEEE Trans. Software Eng.,
39(9):1283-1307, 2013.

[20] M. Gligoric, T. Gvero, V. Jagannath, S. Khurshid, V. Kuncak,
and D. Marinov. Test generation through programming in
UDITA. In ICSE, pages 225-234, 2010.

[21] K. Grygiel and P. Lescanne. Counting and generating lambda
terms. J. Funct. Program., 23(5):594-628, 2013.

[22] K. Grygiel and P. Lescanne. Counting and generating terms in
the binary lambda calculus. J. Funct. Program., 25, 2015.

[23] R. G. Hamlet. Testing programs with the aid of a compiler.
IEEE Trans. Software Eng., 3(4):279-290, 1977.

[24] C. Holler, K. Herzig, and A. Zeller. Fuzzing with code
fragments. In USENIX Security, pages 445-458, 2012.

[25] S. Katayama. Systematic search for lambda expressions. In
TFP, pages 111-126, 2005.

[26] S. Katayama. Efficient exhaustive generation of functional programs using Monte-Carlo search with iterative deepening. In
Proceedings of the 10th Pacific Rim International Conference
on Artificial Intelligence, pages 199-210, 2008.

[27] S. Katayama. An analytical inductive functional programming
system that avoids unintended programs. In PEPM, pages
43-52, 2012.

[28] S. Khurshid and D. Marinov. TestEra: Specification-based
testing of Java programs using SAT. Autom. Softw. Eng., 11(4):
403-434, 2004.

[29] D. E. Knuth. The art of computer programming. Vol. 4A.,
Combinatorial algorithms. Part 1. Addison-Wesley, 2011.

[30] D. L. Kreher and D. R. Stinson. Combinatorial algorithms:
generation, enumeration, and search. CRC Press, London,
New York, 1999.

[31] I. Kuraj, V. Kuncak, and D. Jackson. Programming with
enumerable sets of structures. In OOPSLA, pages 37-56, 2015.

[32] V. Le, M. Afshari, and Z. Su. Compiler validation via equivalence modulo inputs. In PLDI, page 25, 2014.

[33] V. Le, C. Sun, and Z. Su. Finding deep compiler bugs via
guided stochastic program mutation. In OOPSLA, pages 386399, 2015.

[34] V. Le, C. Sun, and Z. Su. Randomized stress-testing of linktime optimizers. In JSSTA, pages 327-337, 2015.

[35] X. Leroy. Formal certification of a compiler back-end or:
programming a compiler with a proof assistant. In POPL,
pages 42-54, 2006.

[36] P. Lescanne. On counting untyped lambda terms.
Comput. Sci., 474:80-97, 2013.

Theor.

[37] C. Lidbury, A. Lascu, N. Chong, and A. F. Donaldson. Manycore compiler fuzzing. In PLDI, pages 65-76, 2015.

[38] T. Mansour and G. Nassar. Gray codes, loopless algorithm and.
partitions. Journal of Mathematical Modelling and Algorithms,
7(3):291-310, 2008.

[39] T. Mansour, G. Nassar, and V. Vajnovszki. Loop-free Gray code
algorithm for the e-restricted growth functions. Information
Processing Letters, 111(11):541-544, 2011.

[40] W. M. McKeeman. Differential testing for software. Digital
Technical Journal, 10(1):100—107, 1998.

[41] E. Nagai, A. Hashimoto, and N. Ishiura. Reinforcing random
testing of arithmetic optimization of C compilers by scaling
up size and number of expressions. 7PSJ Trans. System LST
Design Methodology, 7:91-100, 2014.

[42] G. C. Necula. Translation validation for an optimizing compiler.
In PLDI, pages 83-94, 2000.

[43] F. Nielson, H. R. Nielson, and C. Hankin. Principles of
program analysis. Springer, 1999.

[44] EF W. J. Olver, D. W. Lozier, R. F. Boisvert, and C. W.
Clark, editors. NIST Handbook of Mathematical Functions.
Cambridge University Press, New York, NY, 2010.

[45] M. H. Palka, K. Claessen, A. Russo, and J. Hughes. Testing an
optimising compiler by generating random lambda terms. In
AST, pages 91-97, 2011.

[46] A. Pnueli, M. Siegel, and E. Singerman. Translation validation.
In TACAS, pages 151-166, 1998.

[47] J. Regehr, Y. Chen, P. Cuogq, E. Eide, C. Ellison, and X. Yang.
Test-case reduction for C compiler bugs. In PLDI, pages 335346, 2012.

[48] N. Rosner, V. S. Bengolea, P. Ponzio, S. A. Khalek, N. Aguirre,
M. FE Frias, and S. Khurshid. Bounded exhaustive test input
generation from hybrid invariants. In OOPSLA, pages 655-674,
2014.

[49] C. Runciman, M. Naylor, and F. Lindblad. Smallcheck and
lazy smallcheck: automatic exhaustive testing for small values.
In Haskell, pages 37-48, 2008.

[50] V. Senni and F. Fioravanti. Generation of test data structures
using constraint logic programming. In TAP, pages 115-131,
2012.

[51] K. J. Sullivan, J. Yang, D. Coppit, 8. Khurshid, and D. Jackson.
Software assurance by bounded exhaustive testing. In JSSTA,
pages 133-142, 2004.

[52] C. Sun, V. Le, and Z. Su. Finding and analyzing compiler
warning defects. In ICSE, pages 203-213, 2016.

[53] C. Sun, V. Le, and Z. Su. Finding compiler bugs via live code
mutation. In OOPSLA, pages 849-863, 2016.

[54] C. Sun, V. Le, Q. Zhang, and Z. Su. Toward understanding
compiler bugs in GCC and LLVM. In ISSTA, pages 294-305,
2016.

[55] P. Tarau. On type-directed generation of lambda terms. In
ICLP (Technical Communications), 2015.

[56] W. Visser, C. S. Pasareanu, and S. Khurshid. Test input
generation with Java PathFinder. In JSSTA, pages 97-107,
2004.

[57] X. Yang, Y. Chen, E. Eide, and J. Regehr. Finding and
understanding bugs in C compilers. In PLDI, pages 283-294,
2011.

